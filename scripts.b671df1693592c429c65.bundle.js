webpackJsonp([1],{2:function(n,t,e){n.exports=e("Ogu+")},KF6U:function(n,t){n.exports=function(n){function t(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&function(){return"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener}()?execScript(n):"undefined"!=typeof eval?eval.call(null,n):t("EvalError: No eval function available")}catch(n){t(n)}}},"Ogu+":function(n,t,e){e("KF6U")(e("mWfE"))},mWfE:function(n,t){n.exports="/**\n * Introduction\n * ============\n *\n * The Munkres module provides an implementation of the Munkres algorithm\n * (also called the Hungarian algorithm or the Kuhn-Munkres algorithm),\n * useful for solving the Assignment Problem.\n *\n * Assignment Problem\n * ==================\n *\n * Let C be an n\xd7n-matrix representing the costs of each of n workers\n * to perform any of n jobs. The assignment problem is to assign jobs to\n * workers in a way that minimizes the total cost. Since each worker can perform\n * only one job and each job can be assigned to only one worker the assignments\n * represent an independent set of the matrix C.\n *\n * One way to generate the optimal set is to create all permutations of\n * the indices necessary to traverse the matrix so that no row and column\n * are used more than once. For instance, given this matrix (expressed in\n * Python)\n *\n *  matrix = [[5, 9, 1],\n *        [10, 3, 2],\n *        [8, 7, 4]]\n *\n * You could use this code to generate the traversal indices::\n *\n *  def permute(a, results):\n *    if len(a) == 1:\n *      results.insert(len(results), a)\n *\n *    else:\n *      for i in range(0, len(a)):\n *        element = a[i]\n *        a_copy = [a[j] for j in range(0, len(a)) if j != i]\n *        subresults = []\n *        permute(a_copy, subresults)\n *        for subresult in subresults:\n *          result = [element] + subresult\n *          results.insert(len(results), result)\n *\n *  results = []\n *  permute(range(len(matrix)), results) # [0, 1, 2] for a 3x3 matrix\n *\n * After the call to permute(), the results matrix would look like this::\n *\n *  [[0, 1, 2],\n *   [0, 2, 1],\n *   [1, 0, 2],\n *   [1, 2, 0],\n *   [2, 0, 1],\n *   [2, 1, 0]]\n *\n * You could then use that index matrix to loop over the original cost matrix\n * and calculate the smallest cost of the combinations\n *\n *  n = len(matrix)\n *  minval = sys.maxsize\n *  for row in range(n):\n *    cost = 0\n *    for col in range(n):\n *      cost += matrix[row][col]\n *    minval = min(cost, minval)\n *\n *  print minval\n *\n * While this approach works fine for small matrices, it does not scale. It\n * executes in O(n!) time: Calculating the permutations for an n\xd7x-matrix\n * requires n! operations. For a 12\xd712 matrix, that\u2019s 479,001,600\n * traversals. Even if you could manage to perform each traversal in just one\n * millisecond, it would still take more than 133 hours to perform the entire\n * traversal. A 20\xd720 matrix would take 2,432,902,008,176,640,000 operations. At\n * an optimistic millisecond per operation, that\u2019s more than 77 million years.\n *\n * The Munkres algorithm runs in O(n\xb3) time, rather than O(n!). This\n * package provides an implementation of that algorithm.\n *\n * This version is based on\n * http://csclab.murraystate.edu/~bob.pilgrim/445/munkres.html\n *\n * This version was originally written for Python by Brian Clapper from the\n * algorithm at the above web site (The ``Algorithm::Munkres`` Perl version,\n * in CPAN, was clearly adapted from the same web site.) and ported to\n * JavaScript by Anna Henningsen (addaleax).\n *\n * Usage\n * =====\n *\n * Construct a Munkres object\n *\n *  var m = new Munkres();\n *\n * Then use it to compute the lowest cost assignment from a cost matrix. Here\u2019s\n * a sample program\n *\n *  var matrix = [[5, 9, 1],\n *           [10, 3, 2],\n *           [8, 7, 4]];\n *  var m = new Munkres();\n *  var indices = m.compute(matrix);\n *  console.log(format_matrix(matrix), 'Lowest cost through this matrix:');\n *  var total = 0;\n *  for (var i = 0; i < indices.length; ++i) {\n *    var row = indices[l][0], col = indices[l][1];\n *    var value = matrix[row][col];\n *    total += value;\n *\n *    console.log('(' + rol + ', ' + col + ') -> ' + value);\n *  }\n *\n *  console.log('total cost:', total);\n *\n * Running that program produces::\n *\n *  Lowest cost through this matrix:\n *  [5, 9, 1]\n *  [10, 3, 2]\n *  [8, 7, 4]\n *  (0, 0) -> 5\n *  (1, 1) -> 3\n *  (2, 2) -> 4\n *  total cost: 12\n *\n * The instantiated Munkres object can be used multiple times on different\n * matrices.\n *\n * Non-square Cost Matrices\n * ========================\n *\n * The Munkres algorithm assumes that the cost matrix is square. However, it's\n * possible to use a rectangular matrix if you first pad it with 0 values to make\n * it square. This module automatically pads rectangular cost matrices to make\n * them square.\n *\n * Notes:\n *\n * - The module operates on a *copy* of the caller's matrix, so any padding will\n *   not be seen by the caller.\n * - The cost matrix must be rectangular or square. An irregular matrix will\n *   *not* work.\n *\n * Calculating Profit, Rather than Cost\n * ====================================\n *\n * The cost matrix is just that: A cost matrix. The Munkres algorithm finds\n * the combination of elements (one from each row and column) that results in\n * the smallest cost. It\u2019s also possible to use the algorithm to maximize\n * profit. To do that, however, you have to convert your profit matrix to a\n * cost matrix. The simplest way to do that is to subtract all elements from a\n * large value.\n *\n * The ``munkres`` module provides a convenience method for creating a cost\n * matrix from a profit matrix, i.e. make_cost_matrix.\n *\n * References\n * ==========\n *\n * 1. http://www.public.iastate.edu/~ddoty/HungarianAlgorithm.html\n *\n * 2. Harold W. Kuhn. The Hungarian Method for the assignment problem.\n *    *Naval Research Logistics Quarterly*, 2:83-97, 1955.\n *\n * 3. Harold W. Kuhn. Variants of the Hungarian method for assignment\n *    problems. *Naval Research Logistics Quarterly*, 3: 253-258, 1956.\n *\n * 4. Munkres, J. Algorithms for the Assignment and Transportation Problems.\n *    *Journal of the Society of Industrial and Applied Mathematics*,\n *    5(1):32-38, March, 1957.\n *\n * 5. https://en.wikipedia.org/wiki/Hungarian_algorithm\n *\n * Copyright and License\n * =====================\n * \n * Copyright 2008-2016 Brian M. Clapper\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A very large numerical value which can be used like an integer\n * (i.\xa0e., adding integers of similar size does not result in overflow).\n */\nvar MAX_SIZE = parseInt(Number.MAX_SAFE_INTEGER/2) || ((1 << 26)*(1 << 26));\n\n/**\n * A default value to pad the cost matrix with if it is not quadratic.\n */\nvar DEFAULT_PAD_VALUE = 0;\n\n// ---------------------------------------------------------------------------\n// Classes\n// ---------------------------------------------------------------------------\n\n/**\n * Calculate the Munkres solution to the classical assignment problem.\n * See the module documentation for usage.\n * @constructor\n */\nfunction Munkres() {\n  this.C = null;\n\n  this.row_covered = [];\n  this.col_covered = [];\n  this.n = 0;\n  this.Z0_r = 0;\n  this.Z0_c = 0;\n  this.marked = null;\n  this.path = null;\n}\n\n/**\n * Pad a possibly non-square matrix to make it square.\n *\n * @param {Array} matrix An array of arrays containing the matrix cells\n * @param {Number} [pad_value] The value used to pad a rectangular matrix\n *\n * @return {Array} An array of arrays representing the padded matrix\n */\nMunkres.prototype.pad_matrix = function(matrix, pad_value) {\n  pad_value = pad_value || DEFAULT_PAD_VALUE;\n\n  var max_columns = 0;\n  var total_rows = matrix.length;\n  var i;\n\n  for (i = 0; i < total_rows; ++i)\n    if (matrix[i].length > max_columns)\n      max_columns = matrix[i].length;\n\n  total_rows = max_columns > total_rows ? max_columns : total_rows;\n\n  var new_matrix = [];\n\n  for (i = 0; i < total_rows; ++i) {\n    var row = matrix[i] || [];\n    var new_row = row.slice();\n\n    // If this row is too short, pad it\n    while (total_rows > new_row.length)\n      new_row.push(pad_value);\n\n    new_matrix.push(new_row);\n  }\n\n  return new_matrix;\n};\n\n/**\n * Compute the indices for the lowest-cost pairings between rows and columns\n * in the database. Returns a list of (row, column) tuples that can be used\n * to traverse the matrix.\n *\n * **WARNING**: This code handles square and rectangular matrices.\n * It does *not* handle irregular matrices.\n *\n * @param {Array} cost_matrix The cost matrix. If this cost matrix is not square,\n *                            it will be padded with DEFAULT_PAD_VALUE. Optionally,\n *                            the pad value can be specified via options.padValue.\n *                            This method does *not* modify the caller's matrix.\n *                            It operates on a copy of the matrix.\n * @param {Object} [options] Additional options to pass in\n * @param {Number} [options.padValue] The value to use to pad a rectangular cost_matrix\n *\n * @return {Array} An array of ``(row, column)`` arrays that describe the lowest\n *                 cost path through the matrix\n */\nMunkres.prototype.compute = function(cost_matrix, options) {\n\n  options = options || {};\n  options.padValue = options.padValue || DEFAULT_PAD_VALUE;\n\n  this.C = this.pad_matrix(cost_matrix, options.padValue);\n  this.n = this.C.length;\n  this.original_length = cost_matrix.length;\n  this.original_width = cost_matrix[0].length;\n\n  var nfalseArray = []; /* array of n false values */\n  while (nfalseArray.length < this.n)\n    nfalseArray.push(false);\n  this.row_covered = nfalseArray.slice();\n  this.col_covered = nfalseArray.slice();\n  this.Z0_r = 0;\n  this.Z0_c = 0;\n  this.path =   this.__make_matrix(this.n * 2, 0);\n  this.marked = this.__make_matrix(this.n, 0);\n\n  var step = 1;\n\n  var steps = { 1 : this.__step1,\n                2 : this.__step2,\n                3 : this.__step3,\n                4 : this.__step4,\n                5 : this.__step5,\n                6 : this.__step6 };\n\n  while (true) {\n    var func = steps[step];\n    if (!func) // done\n      break;\n\n    step = func.apply(this);\n  }\n\n  var results = [];\n  for (var i = 0; i < this.original_length; ++i)\n    for (var j = 0; j < this.original_width; ++j)\n      if (this.marked[i][j] == 1)\n        results.push([i, j]);\n\n  return results;\n};\n\n/**\n * Create an n\xd7n matrix, populating it with the specific value.\n *\n * @param {Number} n Matrix dimensions\n * @param {Number} val Value to populate the matrix with\n *\n * @return {Array} An array of arrays representing the newly created matrix\n */\nMunkres.prototype.__make_matrix = function(n, val) {\n  var matrix = [];\n  for (var i = 0; i < n; ++i) {\n    matrix[i] = [];\n    for (var j = 0; j < n; ++j)\n      matrix[i][j] = val;\n  }\n\n  return matrix;\n};\n\n/**\n * For each row of the matrix, find the smallest element and\n * subtract it from every element in its row. Go to Step 2.\n */\nMunkres.prototype.__step1 = function() {\n  for (var i = 0; i < this.n; ++i) {\n    // Find the minimum value for this row and subtract that minimum\n    // from every element in the row.\n    var minval = Math.min.apply(Math, this.C[i]);\n\n    for (var j = 0; j < this.n; ++j)\n      this.C[i][j] -= minval;\n  }\n\n  return 2;\n};\n\n/**\n * Find a zero (Z) in the resulting matrix. If there is no starred\n * zero in its row or column, star Z. Repeat for each element in the\n * matrix. Go to Step 3.\n */\nMunkres.prototype.__step2 = function() {\n  for (var i = 0; i < this.n; ++i) {\n    for (var j = 0; j < this.n; ++j) {\n      if (this.C[i][j] === 0 &&\n        !this.col_covered[j] &&\n        !this.row_covered[i])\n      {\n        this.marked[i][j] = 1;\n        this.col_covered[j] = true;\n        this.row_covered[i] = true;\n        break;\n      }\n    }\n  }\n\n  this.__clear_covers();\n\n  return 3;\n};\n\n/**\n * Cover each column containing a starred zero. If K columns are\n * covered, the starred zeros describe a complete set of unique\n * assignments. In this case, Go to DONE, otherwise, Go to Step 4.\n */\nMunkres.prototype.__step3 = function() {\n  var count = 0;\n\n  for (var i = 0; i < this.n; ++i) {\n    for (var j = 0; j < this.n; ++j) {\n      if (this.marked[i][j] == 1 && this.col_covered[j] == false) {\n        this.col_covered[j] = true;\n        ++count;\n      }\n    }\n  }\n\n  return (count >= this.n) ? 7 : 4;\n};\n\n/**\n * Find a noncovered zero and prime it. If there is no starred zero\n * in the row containing this primed zero, Go to Step 5. Otherwise,\n * cover this row and uncover the column containing the starred\n * zero. Continue in this manner until there are no uncovered zeros\n * left. Save the smallest uncovered value and Go to Step 6.\n */\n\nMunkres.prototype.__step4 = function() {\n  var done = false;\n  var row = -1, col = -1, star_col = -1;\n\n  while (!done) {\n    var z = this.__find_a_zero();\n    row = z[0];\n    col = z[1];\n\n    if (row < 0)\n      return 6;\n\n    this.marked[row][col] = 2;\n    star_col = this.__find_star_in_row(row);\n    if (star_col >= 0) {\n      col = star_col;\n      this.row_covered[row] = true;\n      this.col_covered[col] = false;\n    } else {\n      this.Z0_r = row;\n      this.Z0_c = col;\n      return 5;\n    }\n  }\n};\n\n/**\n * Construct a series of alternating primed and starred zeros as\n * follows. Let Z0 represent the uncovered primed zero found in Step 4.\n * Let Z1 denote the starred zero in the column of Z0 (if any).\n * Let Z2 denote the primed zero in the row of Z1 (there will always\n * be one). Continue until the series terminates at a primed zero\n * that has no starred zero in its column. Unstar each starred zero\n * of the series, star each primed zero of the series, erase all\n * primes and uncover every line in the matrix. Return to Step 3\n */\nMunkres.prototype.__step5 = function() {\n  var count = 0;\n\n  this.path[count][0] = this.Z0_r;\n  this.path[count][1] = this.Z0_c;\n  var done = false;\n\n  while (!done) {\n    var row = this.__find_star_in_col(this.path[count][1]);\n    if (row >= 0) {\n      count++;\n      this.path[count][0] = row;\n      this.path[count][1] = this.path[count-1][1];\n    } else {\n      done = true;\n    }\n\n    if (!done) {\n      var col = this.__find_prime_in_row(this.path[count][0]);\n      count++;\n      this.path[count][0] = this.path[count-1][0];\n      this.path[count][1] = col;\n    }\n  }\n\n  this.__convert_path(this.path, count);\n  this.__clear_covers();\n  this.__erase_primes();\n  return 3;\n};\n\n/**\n * Add the value found in Step 4 to every element of each covered\n * row, and subtract it from every element of each uncovered column.\n * Return to Step 4 without altering any stars, primes, or covered\n * lines.\n */\nMunkres.prototype.__step6 = function() {\n  var minval = this.__find_smallest();\n\n  for (var i = 0; i < this.n; ++i) {\n    for (var j = 0; j < this.n; ++j) {\n      if (this.row_covered[i])\n        this.C[i][j] += minval;\n      if (!this.col_covered[j])\n        this.C[i][j] -= minval;\n    }\n  }\n\n  return 4;\n};\n\n/**\n * Find the smallest uncovered value in the matrix.\n *\n * @return {Number} The smallest uncovered value, or MAX_SIZE if no value was found\n */\nMunkres.prototype.__find_smallest = function() {\n  var minval = MAX_SIZE;\n\n  for (var i = 0; i < this.n; ++i)\n    for (var j = 0; j < this.n; ++j)\n      if (!this.row_covered[i] && !this.col_covered[j])\n        if (minval > this.C[i][j])\n          minval = this.C[i][j];\n\n  return minval;\n};\n\n/**\n * Find the first uncovered element with value 0.\n *\n * @return {Array} The indices of the found element or [-1, -1] if not found\n */\nMunkres.prototype.__find_a_zero = function() {\n  for (var i = 0; i < this.n; ++i)\n    for (var j = 0; j < this.n; ++j)\n      if (this.C[i][j] === 0 &&\n        !this.row_covered[i] &&\n        !this.col_covered[j])\n        return [i, j];\n\n  return [-1, -1];\n};\n\n/**\n * Find the first starred element in the specified row. Returns\n * the column index, or -1 if no starred element was found.\n *\n * @param {Number} row The index of the row to search\n * @return {Number}\n */\n\nMunkres.prototype.__find_star_in_row = function(row) {\n  for (var j = 0; j < this.n; ++j)\n    if (this.marked[row][j] == 1)\n      return j;\n\n  return -1;\n};\n\n/**\n * Find the first starred element in the specified column.\n *\n * @return {Number} The row index, or -1 if no starred element was found\n */\nMunkres.prototype.__find_star_in_col = function(col) {\n  for (var i = 0; i < this.n; ++i)\n    if (this.marked[i][col] == 1)\n      return i;\n\n  return -1;\n};\n\n/**\n * Find the first prime element in the specified row.\n *\n * @return {Number} The column index, or -1 if no prime element was found\n */\n\nMunkres.prototype.__find_prime_in_row = function(row) {\n  for (var j = 0; j < this.n; ++j)\n    if (this.marked[row][j] == 2)\n      return j;\n\n  return -1;\n};\n\nMunkres.prototype.__convert_path = function(path, count) {\n  for (var i = 0; i <= count; ++i)\n    this.marked[path[i][0]][path[i][1]] =\n      (this.marked[path[i][0]][path[i][1]] == 1) ? 0 : 1;\n};\n\n/** Clear all covered matrix cells */\nMunkres.prototype.__clear_covers = function() {\n  for (var i = 0; i < this.n; ++i) {\n    this.row_covered[i] = false;\n    this.col_covered[i] = false;\n  }\n};\n\n/** Erase all prime markings */\nMunkres.prototype.__erase_primes = function() {\n  for (var i = 0; i < this.n; ++i)\n    for (var j = 0; j < this.n; ++j)\n      if (this.marked[i][j] == 2)\n        this.marked[i][j] = 0;\n};\n\n// ---------------------------------------------------------------------------\n// Functions\n// ---------------------------------------------------------------------------\n\n/**\n * Create a cost matrix from a profit matrix by calling\n * 'inversion_function' to invert each value. The inversion\n * function must take one numeric argument (of any type) and return\n * another numeric argument which is presumed to be the cost inverse\n * of the original profit.\n *\n * This is a static method. Call it like this:\n *\n *  cost_matrix = make_cost_matrix(matrix[, inversion_func]);\n *\n * For example:\n *\n *  cost_matrix = make_cost_matrix(matrix, function(x) { return MAXIMUM - x; });\n *\n * @param {Array} profit_matrix An array of arrays representing the matrix\n *                              to convert from a profit to a cost matrix\n * @param {Function} [inversion_function] The function to use to invert each\n *                                       entry in the profit matrix\n *\n * @return {Array} The converted matrix\n */\nfunction make_cost_matrix (profit_matrix, inversion_function) {\n  var i, j;\n  if (!inversion_function) {\n    var maximum = -1.0/0.0;\n    for (i = 0; i < profit_matrix.length; ++i)\n      for (j = 0; j < profit_matrix[i].length; ++j)\n        if (profit_matrix[i][j] > maximum)\n          maximum = profit_matrix[i][j];\n\n    inversion_function = function(x) { return maximum - x; };\n  }\n\n  var cost_matrix = [];\n\n  for (i = 0; i < profit_matrix.length; ++i) {\n    var row = profit_matrix[i];\n    cost_matrix[i] = [];\n\n    for (j = 0; j < row.length; ++j)\n      cost_matrix[i][j] = inversion_function(profit_matrix[i][j]);\n  }\n\n  return cost_matrix;\n}\n\n/**\n * Convenience function: Converts the contents of a matrix of integers\n * to a printable string.\n *\n * @param {Array} matrix The matrix to print\n *\n * @return {String} The formatted matrix\n */\nfunction format_matrix(matrix) {\n  var columnWidths = [];\n  var i, j;\n  for (i = 0; i < matrix.length; ++i) {\n    for (j = 0; j < matrix[i].length; ++j) {\n      var entryWidth = String(matrix[i][j]).length;\n\n      if (!columnWidths[j] || entryWidth >= columnWidths[j])\n        columnWidths[j] = entryWidth;\n    }\n  }\n\n  var formatted = '';\n  for (i = 0; i < matrix.length; ++i) {\n    for (j = 0; j < matrix[i].length; ++j) {\n      var s = String(matrix[i][j]);\n\n      // pad at front with spaces\n      while (s.length < columnWidths[j])\n        s = ' ' + s;\n\n      formatted += s;\n\n      // separate columns\n      if (j != matrix[i].length - 1)\n        formatted += ' ';\n    }\n\n    if (i != matrix[i].length - 1)\n      formatted += '\\n';\n  }\n\n  return formatted;\n}\n\n// ---------------------------------------------------------------------------\n// Exports\n// ---------------------------------------------------------------------------\n\nfunction computeMunkres(cost_matrix, options) {\n  var m = new Munkres();\n  return m.compute(cost_matrix, options);\n}\n\ncomputeMunkres.version = \"1.2.2\";\ncomputeMunkres.format_matrix = format_matrix;\ncomputeMunkres.make_cost_matrix = make_cost_matrix;\ncomputeMunkres.Munkres = Munkres; // backwards compatibility\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = computeMunkres;\n}\n"}},[2]);